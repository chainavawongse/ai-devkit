You are an expert full-stack developer working on this project.

Identify the stack (frontend or backend) and read the appropriate docs first.

---
FRONTEND (React/TypeScript)
---

READ FIRST: frontend/DEVELOPMENT.md, frontend/standards/naming-conventions.md

TECH STACK: React 18 + TypeScript (strict) + Vite + Tailwind CSS + React Query + Zustand + React Hook Form + Zod

FILE NAMING:
- Components: PascalCase (Button.tsx)
- Hooks/utils: camelCase (useDebounce.ts)
- Types: name.types.ts | Tests: name.test.tsx

FOLDER STRUCTURE:
- Features: src/features/[name]/{components,hooks,api,types,index.ts}
- Shared: src/components/{ui,layout} | src/hooks/ | src/lib/utils/

RULES:
- Use @/ path aliases, named exports, React Query for API data
- Zod for validation, aria-labels for icon buttons
- Never: `any`, dangerouslySetInnerHTML without DOMPurify, .spec.ts

PATTERNS: frontend/patterns/ and frontend/examples/

---
BACKEND (.NET API)
---

READ FIRST: backend-dotnet/DEVELOPMENT.md, backend-dotnet/api/standards/naming-conventions.md

TECH STACK: ASP.NET Core 8 + C# 12 + Clean Architecture + CQRS + MediatR + FluentValidation + EF Core 8 + PostgreSQL + OData + Serilog

SOLUTION STRUCTURE:
- MyApp.Api (controllers, middleware)
- MyApp.Services (handlers, validators)
- MyApp.Contracts (DTOs, commands, queries)
- MyApp.Data (entities, DbContext, repositories)
- MyApp.Shared (exceptions, utilities)

RULES:
- Primary constructors for DI, records for DTOs/commands/queries
- FluentValidation for all input, MediatR for dispatch
- AsNoTracking() for reads, CancellationToken on all async
- Never: DateTime.Now (use UtcNow), expose entities (use DTOs), .Result/.Wait()

PATTERNS: backend-dotnet/api/patterns/ and backend-dotnet/api/examples/

---
WHEN UNCERTAIN: Ask for clarification on architecture, security, or conflicting patterns.
